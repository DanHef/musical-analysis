# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type AnalysisSession {
  assignees(
    """Specify to filter the records returned."""
    filter: UserFilter = {}

    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to sort results."""
    sorting: [UserSort!] = []
  ): [User!]
  id: ID!
  moderator: User
  name: String!
  parts(
    """Specify to filter the records returned."""
    filter: PartFilter = {}

    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to sort results."""
    sorting: [PartSort!] = []
  ): [Part!]
  started: DateTime
  stopped: DateTime
  tags(
    """Specify to filter the records returned."""
    filter: TagFilter = {}

    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to sort results."""
    sorting: [TagSort!] = []
  ): [Tag!]
}

type AnalysisSessionAvgAggregate {
  id: Float
}

type AnalysisSessionCountAggregate {
  id: Int
  name: Int
  started: Int
  stopped: Int
}

input AnalysisSessionDeleteFilter {
  and: [AnalysisSessionDeleteFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  or: [AnalysisSessionDeleteFilter!]
  started: DateFieldComparison
  stopped: DateFieldComparison
}

type AnalysisSessionDeleteResponse {
  id: ID
  name: String
  started: DateTime
  stopped: DateTime
}

input AnalysisSessionFilter {
  and: [AnalysisSessionFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  or: [AnalysisSessionFilter!]
  parts: AnalysisSessionFilterPartFilter
  started: DateFieldComparison
  stopped: DateFieldComparison
  tags: AnalysisSessionFilterTagFilter
}

input AnalysisSessionFilterPartFilter {
  and: [AnalysisSessionFilterPartFilter!]
  description: StringFieldComparison
  id: IDFilterComparison
  or: [AnalysisSessionFilterPartFilter!]
  started: DateFieldComparison
  stopped: DateFieldComparison
  submitted: BooleanFieldComparison
  tag: TagEntityFilterComparison
  user: UserEntityFilterComparison
}

input AnalysisSessionFilterTagFilter {
  and: [AnalysisSessionFilterTagFilter!]
  description: StringFieldComparison
  id: IDFilterComparison
  name: StringFieldComparison
  or: [AnalysisSessionFilterTagFilter!]
}

type AnalysisSessionMaxAggregate {
  id: ID
  name: String
  started: DateTime
  stopped: DateTime
}

type AnalysisSessionMinAggregate {
  id: ID
  name: String
  started: DateTime
  stopped: DateTime
}

input AnalysisSessionSort {
  direction: SortDirection!
  field: AnalysisSessionSortFields!
  nulls: SortNulls
}

enum AnalysisSessionSortFields {
  id
  name
  started
  stopped
}

type AnalysisSessionSumAggregate {
  id: Float
}

input AnalysisSessionUpdateFilter {
  and: [AnalysisSessionUpdateFilter!]
  id: IDFilterComparison
  name: StringFieldComparison
  or: [AnalysisSessionUpdateFilter!]
  started: DateFieldComparison
  stopped: DateFieldComparison
}

input BooleanFieldComparison {
  is: Boolean
  isNot: Boolean
}

input CreateAnalysisSession {
  id: ID
  name: String
  started: DateTime
  stopped: DateTime
}

input CreateManyAnalysisSessionsInput {
  """Array of records to create"""
  analysisSessions: [CreateAnalysisSession!]!
}

input CreateManyPartsInput {
  """Array of records to create"""
  parts: [CreatePart!]!
}

input CreateManyTagsInput {
  """Array of records to create"""
  tags: [CreateTag!]!
}

input CreateManyUsersInput {
  """Array of records to create"""
  users: [CreateUser!]!
}

input CreateOneAnalysisSessionInput {
  """The record to create"""
  analysisSession: CreateAnalysisSession!
}

input CreateOnePartInput {
  """The record to create"""
  part: CreatePart!
}

input CreateOneTagInput {
  """The record to create"""
  tag: CreateTag!
}

input CreateOneUserInput {
  """The record to create"""
  user: CreateUser!
}

input CreatePart {
  description: String
  id: ID
  started: DateTime
  stopped: DateTime
  submitted: Boolean
  tag: TagEntity
  user: UserEntity
}

input CreateTag {
  description: String
  id: ID
  name: String
}

input CreateUser {
  email: String
  firstname: String
  id: ID
  lastname: String
  username: String
}

input DateFieldComparison {
  between: DateFieldComparisonBetween
  eq: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  is: Boolean
  isNot: Boolean
  lt: DateTime
  lte: DateTime
  neq: DateTime
  notBetween: DateFieldComparisonBetween
  notIn: [DateTime!]
}

input DateFieldComparisonBetween {
  lower: DateTime!
  upper: DateTime!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input DeleteManyAnalysisSessionsInput {
  """Filter to find records to delete"""
  filter: AnalysisSessionDeleteFilter!
}

input DeleteManyPartsInput {
  """Filter to find records to delete"""
  filter: PartDeleteFilter!
}

type DeleteManyResponse {
  """The number of records deleted."""
  deletedCount: Int!
}

input DeleteManyTagsInput {
  """Filter to find records to delete"""
  filter: TagDeleteFilter!
}

input DeleteManyUsersInput {
  """Filter to find records to delete"""
  filter: UserDeleteFilter!
}

input DeleteOneInput {
  """The id of the record to delete."""
  id: ID!
}

input IDFilterComparison {
  eq: ID
  gt: ID
  gte: ID
  iLike: ID
  in: [ID!]
  is: Boolean
  isNot: Boolean
  like: ID
  lt: ID
  lte: ID
  neq: ID
  notILike: ID
  notIn: [ID!]
  notLike: ID
}

type Mutation {
  addAssigneesToAnalysisSession(input: RelationsInput!): AnalysisSession!
  addPartsToAnalysisSession(input: RelationsInput!): AnalysisSession!
  addPartsToTag(input: RelationsInput!): Tag!
  addTagsToAnalysisSession(input: RelationsInput!): AnalysisSession!
  createManyAnalysisSessions(input: CreateManyAnalysisSessionsInput!): [AnalysisSession!]!
  createManyParts(input: CreateManyPartsInput!): [Part!]!
  createManyTags(input: CreateManyTagsInput!): [Tag!]!
  createManyUsers(input: CreateManyUsersInput!): [User!]!
  createOneAnalysisSession(input: CreateOneAnalysisSessionInput!): AnalysisSession!
  createOnePart(input: CreateOnePartInput!): Part!
  createOneTag(input: CreateOneTagInput!): Tag!
  createOneUser(input: CreateOneUserInput!): User!
  deleteManyAnalysisSessions(input: DeleteManyAnalysisSessionsInput!): DeleteManyResponse!
  deleteManyParts(input: DeleteManyPartsInput!): DeleteManyResponse!
  deleteManyTags(input: DeleteManyTagsInput!): DeleteManyResponse!
  deleteManyUsers(input: DeleteManyUsersInput!): DeleteManyResponse!
  deleteOneAnalysisSession(input: DeleteOneInput!): AnalysisSessionDeleteResponse!
  deleteOnePart(input: DeleteOneInput!): PartDeleteResponse!
  deleteOneTag(input: DeleteOneInput!): TagDeleteResponse!
  deleteOneUser(input: DeleteOneInput!): UserDeleteResponse!
  removeAnalysisSessionFromPart(input: RelationInput!): Part!
  removeAssigneesFromAnalysisSession(input: RelationsInput!): AnalysisSession!
  removeModeratorFromAnalysisSession(input: RelationInput!): AnalysisSession!
  removePartsFromAnalysisSession(input: RelationsInput!): AnalysisSession!
  removePartsFromTag(input: RelationsInput!): Tag!
  removePartsFromUser(input: RelationInput!): User!
  removeTagFromPart(input: RelationInput!): Part!
  removeTagsFromAnalysisSession(input: RelationsInput!): AnalysisSession!
  removeUserFromPart(input: RelationInput!): Part!
  setAnalysisSessionOnPart(input: RelationInput!): Part!
  setModeratorOnAnalysisSession(input: RelationInput!): AnalysisSession!
  setPartsOnUser(input: RelationInput!): User!
  setTagOnPart(input: RelationInput!): Part!
  setUserOnPart(input: RelationInput!): Part!
  syncUsers(id: ID!): [User!]!
  updateManyAnalysisSessions(input: UpdateManyAnalysisSessionsInput!): UpdateManyResponse!
  updateManyParts(input: UpdateManyPartsInput!): UpdateManyResponse!
  updateManyTags(input: UpdateManyTagsInput!): UpdateManyResponse!
  updateManyUsers(input: UpdateManyUsersInput!): UpdateManyResponse!
  updateOneAnalysisSession(input: UpdateOneAnalysisSessionInput!): AnalysisSession!
  updateOnePart(input: UpdateOnePartInput!): Part!
  updateOneTag(input: UpdateOneTagInput!): Tag!
  updateOneUser(input: UpdateOneUserInput!): User!
}

input OffsetPaging {
  """Limit the number of records returned"""
  limit: Int

  """Offset to start returning records from"""
  offset: Int
}

type Part {
  analysisSession: AnalysisSession
  description: String
  id: ID!
  started: DateTime
  stopped: DateTime
  submitted: Boolean!
  tag: Tag
  user: User
}

type PartAvgAggregate {
  id: Float
}

type PartCountAggregate {
  description: Int
  id: Int
  started: Int
  stopped: Int
  submitted: Int
  tag: Int
  user: Int
}

input PartDeleteFilter {
  and: [PartDeleteFilter!]
  description: StringFieldComparison
  id: IDFilterComparison
  or: [PartDeleteFilter!]
  started: DateFieldComparison
  stopped: DateFieldComparison
  submitted: BooleanFieldComparison
  tag: TagEntityFilterComparison
  user: UserEntityFilterComparison
}

type PartDeleteResponse {
  description: String
  id: ID
  started: DateTime
  stopped: DateTime
  submitted: Boolean
  tag: Tag
  user: User
}

input PartEntity {
  description: String
  id: ID!
  started: DateTime
  stopped: DateTime
  submitted: Boolean!
  tag: TagEntity!
  user: UserEntity!
}

input PartFilter {
  and: [PartFilter!]
  description: StringFieldComparison
  id: IDFilterComparison
  or: [PartFilter!]
  started: DateFieldComparison
  stopped: DateFieldComparison
  submitted: BooleanFieldComparison
  tag: TagEntityFilterComparison
  user: UserEntityFilterComparison
}

type PartMaxAggregate {
  description: String
  id: ID
  started: DateTime
  stopped: DateTime
  tag: Tag
  user: User
}

type PartMinAggregate {
  description: String
  id: ID
  started: DateTime
  stopped: DateTime
  tag: Tag
  user: User
}

input PartSort {
  direction: SortDirection!
  field: PartSortFields!
  nulls: SortNulls
}

enum PartSortFields {
  description
  id
  started
  stopped
  submitted
  tag
  user
}

type PartSumAggregate {
  id: Float
}

input PartUpdateFilter {
  and: [PartUpdateFilter!]
  description: StringFieldComparison
  id: IDFilterComparison
  or: [PartUpdateFilter!]
  started: DateFieldComparison
  stopped: DateFieldComparison
  submitted: BooleanFieldComparison
  tag: TagEntityFilterComparison
  user: UserEntityFilterComparison
}

type Query {
  analysisSession(
    """The id of the record to find."""
    id: ID!
  ): AnalysisSession
  analysisSessions(
    """Specify to filter the records returned."""
    filter: AnalysisSessionFilter = {}

    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to sort results."""
    sorting: [AnalysisSessionSort!] = []
  ): [AnalysisSession!]!
  part(
    """The id of the record to find."""
    id: ID!
  ): Part
  parts(
    """Specify to filter the records returned."""
    filter: PartFilter = {}

    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to sort results."""
    sorting: [PartSort!] = []
  ): [Part!]!
  tag(
    """The id of the record to find."""
    id: ID!
  ): Tag
  tags(
    """Specify to filter the records returned."""
    filter: TagFilter = {}

    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to sort results."""
    sorting: [TagSort!] = []
  ): [Tag!]!
  user(
    """The id of the record to find."""
    id: ID!
  ): User
  users(
    """Specify to filter the records returned."""
    filter: UserFilter = {}

    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to sort results."""
    sorting: [UserSort!] = []
  ): [User!]!
}

input RelationInput {
  """The id of the record."""
  id: ID!

  """The id of relation."""
  relationId: ID!
}

input RelationsInput {
  """The id of the record."""
  id: ID!

  """The ids of the relations."""
  relationIds: [ID!]!
}

"""Sort Directions"""
enum SortDirection {
  ASC
  DESC
}

"""Sort Nulls Options"""
enum SortNulls {
  NULLS_FIRST
  NULLS_LAST
}

input StringFieldComparison {
  eq: String
  gt: String
  gte: String
  iLike: String
  in: [String!]
  is: Boolean
  isNot: Boolean
  like: String
  lt: String
  lte: String
  neq: String
  notILike: String
  notIn: [String!]
  notLike: String
}

type Tag {
  description: String
  id: ID!
  name: String
  parts(
    """Specify to filter the records returned."""
    filter: PartFilter = {}

    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to sort results."""
    sorting: [PartSort!] = []
  ): [Part!]
}

type TagAvgAggregate {
  id: Float
}

type TagCountAggregate {
  description: Int
  id: Int
  name: Int
}

input TagDeleteFilter {
  and: [TagDeleteFilter!]
  description: StringFieldComparison
  id: IDFilterComparison
  name: StringFieldComparison
  or: [TagDeleteFilter!]
}

type TagDeleteResponse {
  description: String
  id: ID
  name: String
}

input TagEntity {
  description: String
  id: ID!
  name: String
}

input TagEntityFilterComparison {
  eq: TagEntity
  gt: TagEntity
  gte: TagEntity
  iLike: TagEntity
  in: [TagEntity!]
  is: Boolean
  isNot: Boolean
  like: TagEntity
  lt: TagEntity
  lte: TagEntity
  neq: TagEntity
  notILike: TagEntity
  notIn: [TagEntity!]
  notLike: TagEntity
}

input TagFilter {
  and: [TagFilter!]
  description: StringFieldComparison
  id: IDFilterComparison
  name: StringFieldComparison
  or: [TagFilter!]
}

type TagMaxAggregate {
  description: String
  id: ID
  name: String
}

type TagMinAggregate {
  description: String
  id: ID
  name: String
}

input TagSort {
  direction: SortDirection!
  field: TagSortFields!
  nulls: SortNulls
}

enum TagSortFields {
  description
  id
  name
}

type TagSumAggregate {
  id: Float
}

input TagUpdateFilter {
  and: [TagUpdateFilter!]
  description: StringFieldComparison
  id: IDFilterComparison
  name: StringFieldComparison
  or: [TagUpdateFilter!]
}

input UpdateAnalysisSession {
  id: ID
  name: String
  started: DateTime
  stopped: DateTime
}

input UpdateManyAnalysisSessionsInput {
  """Filter used to find fields to update"""
  filter: AnalysisSessionUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateAnalysisSession!
}

input UpdateManyPartsInput {
  """Filter used to find fields to update"""
  filter: PartUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdatePart!
}

type UpdateManyResponse {
  """The number of records updated."""
  updatedCount: Int!
}

input UpdateManyTagsInput {
  """Filter used to find fields to update"""
  filter: TagUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateTag!
}

input UpdateManyUsersInput {
  """Filter used to find fields to update"""
  filter: UserUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateUser!
}

input UpdateOneAnalysisSessionInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateAnalysisSession!
}

input UpdateOnePartInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdatePart!
}

input UpdateOneTagInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateTag!
}

input UpdateOneUserInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateUser!
}

input UpdatePart {
  description: String
  id: ID
  started: DateTime
  stopped: DateTime
  submitted: Boolean
  tag: TagEntity
  user: UserEntity
}

input UpdateTag {
  description: String
  id: ID
  name: String
}

input UpdateUser {
  email: String
  firstname: String
  id: ID
  lastname: String
  username: String
}

type User {
  email: String
  firstname: String
  id: ID!
  lastname: String
  parts: Part
  username: String
}

type UserAvgAggregate {
  id: Float
}

type UserCountAggregate {
  email: Int
  firstname: Int
  id: Int
  lastname: Int
  username: Int
}

input UserDeleteFilter {
  and: [UserDeleteFilter!]
  email: StringFieldComparison
  firstname: StringFieldComparison
  id: IDFilterComparison
  lastname: StringFieldComparison
  or: [UserDeleteFilter!]
  username: StringFieldComparison
}

type UserDeleteResponse {
  email: String
  firstname: String
  id: ID
  lastname: String
  username: String
}

input UserEntity {
  email: String
  firstname: String
  id: ID!
  lastname: String
  username: String
}

input UserEntityFilterComparison {
  eq: UserEntity
  gt: UserEntity
  gte: UserEntity
  iLike: UserEntity
  in: [UserEntity!]
  is: Boolean
  isNot: Boolean
  like: UserEntity
  lt: UserEntity
  lte: UserEntity
  neq: UserEntity
  notILike: UserEntity
  notIn: [UserEntity!]
  notLike: UserEntity
}

input UserFilter {
  and: [UserFilter!]
  email: StringFieldComparison
  firstname: StringFieldComparison
  id: IDFilterComparison
  lastname: StringFieldComparison
  or: [UserFilter!]
  parts: UserFilterPartFilter
  username: StringFieldComparison
}

input UserFilterPartFilter {
  and: [UserFilterPartFilter!]
  description: StringFieldComparison
  id: IDFilterComparison
  or: [UserFilterPartFilter!]
  started: DateFieldComparison
  stopped: DateFieldComparison
  submitted: BooleanFieldComparison
  tag: TagEntityFilterComparison
  user: UserEntityFilterComparison
}

type UserMaxAggregate {
  email: String
  firstname: String
  id: ID
  lastname: String
  username: String
}

type UserMinAggregate {
  email: String
  firstname: String
  id: ID
  lastname: String
  username: String
}

input UserSort {
  direction: SortDirection!
  field: UserSortFields!
  nulls: SortNulls
}

enum UserSortFields {
  email
  firstname
  id
  lastname
  username
}

type UserSumAggregate {
  id: Float
}

input UserUpdateFilter {
  and: [UserUpdateFilter!]
  email: StringFieldComparison
  firstname: StringFieldComparison
  id: IDFilterComparison
  lastname: StringFieldComparison
  or: [UserUpdateFilter!]
  username: StringFieldComparison
}
